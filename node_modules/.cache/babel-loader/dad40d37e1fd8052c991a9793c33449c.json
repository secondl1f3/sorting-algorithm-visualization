{"ast":null,"code":"var _jsxFileName = \"/Users/ahmadfajar/Masters/Computer Science/Algorithm/sorting/hw3/sort-visualizer/src/algorithms/MergeSort.js\";\nimport React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst MergeSort = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n\n      k++;\n    }\n\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original; // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2); // Visualize: First Half\n\n    addToTrace(trace, original, [], [...Array(midPoint - start).keys()].map(i => i + start));\n    recursiveMergeSort(original, start, midPoint); // Visualize: Second Half\n\n    addToTrace(trace, original, [], [...Array(end - midPoint).keys()].map(i => i + midPoint));\n    recursiveMergeSort(original, midPoint, end);\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length); // Visualize: Mark all elements as sorted\n\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\n_c = MergeSort;\nexport const MergeSortKey = createKey('Call Merge Sort', null, 'Overwrite from axillary array');\nexport const MergeSortDesc = {\n  title: 'Merge Sort',\n  description: /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: [/*#__PURE__*/_jsxDEV(\"a\", {\n        href: \"https://en.wikipedia.org/wiki/Merge_sort\",\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        children: \"Merge Sort\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 96,\n        columnNumber: 9\n      }, this), ' ', \"is an efficient, stable sorting algorith that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"ol\", {\n      children: [/*#__PURE__*/_jsxDEV(\"li\", {\n        children: [\"Divide the unsorted list into \", /*#__PURE__*/_jsxDEV(\"em\", {\n          children: \"n\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 109,\n          columnNumber: 41\n        }, this), \" sublists, each containing one element(a list of one element is considered sorted)\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 108,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: \"Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 113,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 94,\n    columnNumber: 5\n  }, this),\n  worstCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 122,\n    columnNumber: 5\n  }, this),\n  avgCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 127,\n    columnNumber: 5\n  }, this),\n  bestCase: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 9\n    }, this), \" log \", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 24\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 132,\n    columnNumber: 5\n  }, this),\n  space: /*#__PURE__*/_jsxDEV(\"span\", {\n    children: [\"O(\", /*#__PURE__*/_jsxDEV(\"em\", {\n      children: \"n\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 9\n    }, this), \")\"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 137,\n    columnNumber: 5\n  }, this)\n};\nexport default MergeSort;\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeSort\");","map":{"version":3,"sources":["/Users/ahmadfajar/Masters/Computer Science/Algorithm/sorting/hw3/sort-visualizer/src/algorithms/MergeSort.js"],"names":["React","newTrace","addToTrace","createKey","MergeSort","nums","trace","merge","original","start","mid","end","left","slice","right","i","j","k","length","recursiveMergeSort","midPoint","Math","floor","Array","keys","map","MergeSortKey","MergeSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = (nums) => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n      k++;\n    }\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original;\n      // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2);\n\n    // Visualize: First Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(midPoint - start).keys()].map((i) => i + start)\n    );\n    recursiveMergeSort(original, start, midPoint);\n\n    // Visualize: Second Half\n    addToTrace(\n      trace,\n      original,\n      [],\n      [...Array(end - midPoint).keys()].map((i) => i + midPoint)\n    );\n    recursiveMergeSort(original, midPoint, end);\n\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length);\n\n  // Visualize: Mark all elements as sorted\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const MergeSortKey = createKey(\n  'Call Merge Sort',\n  null,\n  'Overwrite from axillary array'\n);\nexport const MergeSortDesc = {\n  title: 'Merge Sort',\n  description: (\n    <div>\n      <p>\n        <a\n          href=\"https://en.wikipedia.org/wiki/Merge_sort\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Merge Sort\n        </a>{' '}\n        is an efficient, stable sorting algorith that makes use of the\n        divide and conquer strategy. Conceptually the algorithm works as\n        follows:\n      </p>\n      <ol>\n        <li>\n          Divide the unsorted list into <em>n</em> sublists, each\n          containing one element(a list of one element is considered\n          sorted)\n        </li>\n        <li>\n          Repeatedly merge sublists to produce new sorted sublists until\n          there is only one sublist remaining. This will be the sorted\n          list.\n        </li>\n      </ol>\n    </div>\n  ),\n  worstCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  avgCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  bestCase: (\n    <span>\n      O(<em>n</em> log <em>n</em>)\n    </span>\n  ),\n  space: (\n    <span>\n      O(<em>n</em>)\n    </span>\n  )\n};\nexport default MergeSort;\n"]},"metadata":{},"sourceType":"module"}